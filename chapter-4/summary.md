# 4章 シンタックスとセマンティクス

- 駆け足のツアーはこれでおしまい
- ここからは今までに使った機能を体系的に見ていく
- そのまえによくある質問に答えておく

## 4.1 なんでこんなに括弧があるの？

- Lispの特徴は 括弧の多用 と 前置記法
- Lispのシンタックスはマクロを知ると理解できる
- Jhon Mcarthy(Lispの神様) 曰く
  - 最初はLispでM式（Algolに似たシンタックス）を使う予定だった
  - 完成することができなかった
  - S式を気に入るプログラマが出てきた

## 4.2 ブラックボックスをばらして中を見てみると

- 大抵の言語処理系
  - 内部構造はフェーズごとに別れたブラックボックス
  - ブラックボックス中でプログラムを実行している
  - よくあるのは処理系を3つのフェーズに分解
    - 字句解析器；文字列を分割し字句へ落とし込む
    - パーサ；抽象構文木（ATL）を作る
    - 評価器；抽象構文木（ATL）を評価し実行する

- CommonLispの場合
  - 2つのブラックボックス
    - 読取器；reader
      - 文字列がどのようなS式になるか決める
    - 評価器；evaluter
      - S式からLispのフォームを決める
      - Lispフォーム；括弧先頭がデータではないもの
  - 利点
    - S式を外部における
    - プログラムでのS式の組み立てが簡単
    - プログラムをコード内で簡単に生成可能

## 4.3 S式

- 読取器がどのようにS式を読みこんでいくか
- S式の基本的な構成要素；リストとアトム
- リスト
  - 空白で区切られた要素
  - 要素；S式
- アトム
  - 数値
    - 数字の列
    - 数字列に記号が含まれていても数値 (`-1/2`, `1.0d0`)
  - 文字リテラル
    - ダブルクオートで囲まれた文字
    - ダブルクオート、バックスラッシュだけは エスケープの必要あり
    - エスケープ文字はバックスラッシュ
  - シンボル
    - 関数名、変数名
    - 読み取り機はシンボルを区別しない
    - シンボルに使える文字
      - ほとんど使える
      - 数値として認識されなければ数字も使える
      - ピリオドだけで構成されるシンボルは使えない
    - シンボルに使えない文字
      - 空白文字は使えない
      - `()"'`.,:;\|` は別のシンタックスに使用されているため使えない
    - 読取器が シンボルオブジェクトを作る方法
      - 英子文字は全て大文字に; `foo` -> `FOO`
      - |、\ がついている場合はそのまま；`|foo|` -> `foo`, `\f\o\o` -> `foo`
- シンボル名で同一オブジェクトであることを保証するしくみ
  - 読取器がシンボルのインターン（intern）を行う
  - シンボルをパッケージ（package）に保存
  - 新しいシンボルを見つけたら大文字変換→パッケージ内検索
  - 見つかったらそれを使い、見つからなかったら新たに追加 
- Lispの命名規約
  - ハイフンを使った命名；`hello-world`（ケバブケース）
  - ダイナミック変数(スペシャル変数)の先頭と末尾に「＊」をつける；`*db*`
  - 定数の先頭と末尾に「＋」をつける
  - 下位層の関数の先頭に「%」「%%」をつけるプログラマもいる

## 4.4 Lispフォームとしての式

- 評価器はすべてのS式を評価できるわけではない
  - 評価できるのは Lispフォーム
  - well-formed（きちんとした形式）なLispフォーム
  - Lispフォーム；先頭要素がシンボルになっているリスト
- 評価器は Lispフォームを受け取って値（value）を返す

- Lispフォームとは
  - アトム
    - シンボル；変数、定数
      - 自己参照型；T、NIL
      - キーワードシンボル(keyword symbol); 先頭に：がついたシンボル
    - 自己評価型；文字列、数値、シンボル
- 正規のリストフォームは3種類に別れる
  - 関数呼び出しフォーム
  - マクロフォーム
  - 特殊フォーム

## 4.5 関数呼び出し

- 関数呼び出し時の評価ルール
  - 先頭以外の要素を評価
  - その結果を関数に渡す
- 関数呼び出しの基本的なシンタックス
  - `(function-name argument*)`
  - function-name; 関数名
  - argument; Lisp式

## 4.6 特殊オペレータ

- 関数の先頭要素以外は全て関数呼び出し前に評価される
- 特殊オペレータ；引数要素の評価タイミングが特殊な関数
- 影響の範囲
  - 評価器で特別な処理が必要になるもの（IF, LET ...
  - 読取器で特別な評価が必要になるもの (QUOTE

- ex)
  - IF関数
    - （if (flg) (true) (false))
    - flg の状態によって後続引数の評価をしたくない
  - let関数
    - (let ((x 2)) x)
    - 他のフォームが評価されるときに影響
  - quote関数
    - '(+ 1 2)
    - (quote (+ 1 2)) と同じになる
    - (+ 1 2) 評価されない

- 特殊オペレータの実現方法
  - マクロで実装してるのか

- リーダーマクロ
  - QUOTE は 読取器の動作を変えるのでリーダマクロ
  - リーダーマクロの拡張方法はあるがほとんど使われない
  - Lisperが言うシンタックス拡張はたいてい普通のマクロを指している

## 4.7 マクロ

- 特殊オペレータの拡張方法を提供するのがマクロ
- 評価される前にS式を受取り、Lispフォームを返す

- マクロの評は二段階で進行する
  - マクロ関数がマクロを展開する
  - マクロ関数が返すフォームが通常の評価手順で評価される
  - 上記二段階のフェーズはは全く別のタイミングで起きる

- 利点；コンパイル前にマクロ展開
  - Lispコードのコンパイルができる
  - コンパイル後のファイルではマクロ展開のコストが０になる

- マクロ関数に渡すS式は Lsipフォームである必要がない
  - マクロ関数が理解できる形で良い
  - マクロ関数でローカルなシンタックスを定義できる

## 4.8 真、偽、そしてひとしさ

- 真偽の表現
  - 偽；nil、`()`、``nil`、``()`
    - NILは値としてシンボルNILを持つ定数
      - 値としてシンボルをもつ。。。？
      - 特殊なシンボルっていう理解でいいのかな
  - 真；`nil`以外


- オブジェクトの同一性
  - 等しいことを調べる関数
    - EQ; 参照の同一性確認
    - EQL;クラス、値までの同一性をしらべる
    - EQUAL;値の同一性を調べる
    - EQUALP;値の同一性を調べる。大文字小文字を区別しない `(equalp 1 1.0)`

- eq, eql などの使い分け
  - eq, eql を使わけろ派
    - 評価コストが高いから使い分けたほうがいい
  - 全部eqlで統一しろ派
    - eq を使っていい場所化を判断するほうが大変

## 4.9 Lispコードの書式付け

- コードの読みやすさを考えるたインデックスが大事
- インデックスを適切につけるとカッコの数を数えなくて良くなる
- 大抵、エディタにコードフォーマッタがついてるから使うべきだよ
  - VIM でのコードフォーマッタ探しておこう







