# 第8章 マクロ：自分で定義しよう

- 自分でマクロを書く方法を説明する
- マクロは言語の一部分
  - マクロによってコア言語と標準ライブラリの上に抽象化を作る
- マクロを理解する最大の障壁
  - うまく言語に統合されてしまっていること
  - 関数とマクロの区別がつかない
- マクロは関数とは大きく違う

## 8.1 マック初めて物語

<省略>

## 8.2 マクロ展開時 vs. 実行時

- マクロ展開と実行は明確に区別される
  - マクロが動作する時間；マクロ展開時（macro expantion time）
  - 通常のコードが実行される時間（runtime）
- マクロ展開時と実行時 は時間的に絡み合っており境界がはっきりしない
  - 言語仕様でマクロ展開のタイミングは規定されていない
    - 全てのマクロを展開し終わったあとに実行するのか
    - 順次マクロ展開し、実行するのか
- マクロ展開時にはソースコード内に存在している情報のみ使用できる
- マクロは未評価のLispオブジェクトを受取、プログラムを作り出すのが役割

## 8.3 DEFMACRO

- マクロは`DEFMACRO`フォームで定義される
- `DEFUN` にとても良く似ている
```
(defmacro name (parameter*)
  "省略可能なドキュメンテーション文字列"
  body-form)
```

- マクロを書くステップ
  - どのようなコードを作り出したいかを理解していなくてはならない
    - マクロ呼び出しの例
    - 展開後のコード
  - 展開するコードを書く
    - 単純なマクロ
  　  - 展開後のコードに適切なパラメータを挿入
      - バッククォートしたテンプレートを書く
    - 複雑なマクロ
      - 補助関数とデータ構造を完備した独立したプログラム
  - 漏れを塞ぐ
    - 抽象化の漏れを塞ぐ
    - 詳細は8.7章で解説

## 8.4 試しにマクロを書いてみる

- 実際に `do-primes` というマクロを書いていく
- あくまでもデモンストレーションなので実用的ではない

- 補助関数が2つ
  - 与えられた数が素数かどうかを判定する関数
  - 与えられた引数と同じかそれより大きい次の素数を返す

```
(defun primep (number)
  (when (> number 1)
    (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))
```


